C standard libraries:

// https://www-s.acm.illinois.edu/webmonkeys/book/c_guide/
// http://www.runoob.com/cprogramming/c-tutorial.html
<assert.h>     <ctype.h>     <errno.h>      <float.h>      <limts.h>
<locale.h>     <math.h>      <setjmp.h>     <signal.h>     <stdarg.h>
<stddef.h>     <stdio.h>     <stdlib.h>     <string.h>     <time.h>



=======================================================================
<assert.h>

This header file provides a macro called assert that is used to verify assumptions made by the program and print a diagnostic message if this assumption is false.


1. void assert(int expression): It is actually a macro and not a function, which is used to add diagnostics in your C program. If expression evaluates to TRUE, assert() does nothing. If expression evaluates to FALSE, assert() displays an error message on stderr and aborts program execution.


assert.h提供了一个名为 assert 的宏，用于验证程序做出的假设，并在假设为false时输出诊断消息。
已定义的宏 assert 指向另一个宏 NDEBUG，宏 NDEBUG 不是 <assert.h> 的一部分。如果已在引用 <assert.h> 的源文件中定义 NDEBUG 为宏名称，则 assert 宏的定义如下：
#define assert(ignore) ((void)0)

#include <assert.h>
void assert( int expression ); // http://www.cnblogs.com/ggzss/archive/2011/08/18/2145017.html
作用是计算表达式 expression，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后调用 abort 来终止程序运行。

assert()的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include <assert.h>的语句之前插入 #define NDEBUG 来禁用assert调用
#define NDEBUG
#include <assert.h>

用法总结与注意事项：
1）在函数开始处检验传入参数的合法性
2）每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是哪个条件失败
3）不能使用改变环境的语句
4）assert和后面的语句应空一行，以形成逻辑和视觉上的一致感
5）有的地方，assert不能代替条件过滤。
assert是用来避免显而易见的错误的，而不是处理异常的。错误和异常是不一样的，错误是不应该出现的，异常是不可避免的。c语言异常可以通过条件判断来处理。
assert的使用规律是，在方法或者函数的最开始使用，如果在方法的中间使用则需要慎重考虑是否是应该的。方法的最开始还没开始一个功能过程，在一个功能过程执行中出现的问题几乎都是异常


=======================================================================
<ctype.h>

The header file declares several functions that are useful for testing and mapping characters. All the functions accepts int as a parameter, whose value must be EOF or representable as an unsigned char. All the functions return non-zero (true) if the argument c satisfies the condition described, and zero (false) if not.


1. int isalnum(int c):   checks whether the passed character is alphanumeric (returns non-zero value if c is a digit or a letter, else it returns 0)
2. int isalpha(int c):   checks whether the passed character is alphabetic ( returns non-zero value if c is an alphabet, else it returns 0)
3. int iscntrl(int c):   checks whether the passed character is control character
4. int isdigit(int c):   checks whether the passed character is decimal digit (0~9)
5. int isgraph(int c):   checks whether the passed character has graphical representation using locale. The characters can be printed except for whitespace characters
6. int islower(int c):   checks whether the passed character is lowercase letter
7. int isprint(int c):   checks whether the passed character is printable. A printable character is a character that is not a control character
8. int ispunct(int c):   checks whether the passed character is a punctuation character
9. int isspace(int c):   checks whether the passed character is white-space
10. int isupper(int c):  checks whether the passed character is an uppercase letter
11. int isxdigit(int c): checks whether the passed character is a hexadecimal digit
12. int tolower(int c):  converts uppercase letters to lowercase. The function return an int value that can be implicitly casted to char
13. int toupper(int c):  converts lowercase letters to uppercase. The function return an int value that can be implicitly casted to char


Character Classes
1. Digits:                   This is a set of whole numbers { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }.
2.Hexadecimal digits:        This is the set of - { 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f }.
3. Lowercase letters:        This is a set of lowercase letters { a b c d e f g h i j k l m n o p q r s t u v w x y z }.
4. Uppercase letters:        This is a set of uppercase letters {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z }.
5. Letters:                  This is a set of lowercase and uppercase letters.
6. Alphanumeric characters:  This is a set of Digits, Lowercase letters and Uppercase letters.
7. Punctuation characters:   This is a set of ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
8. Graphical characters:     This is a set of Alphanumeric characters and Punctuation characters.
9. Space characters:         This is a set of tab, newline, vertical tab, form feed, carriage return, and space.
10. Printable characters:    This is a set of Alphanumeric characters, Punctuation characters and Space characters.
11. Control characters:      In ASCII, these characters have octal codes 000 through 037, and 177 (DEL)
12. Blank characters:        These are spaces and tabs.
13. Alphabetic characters:   This is a set of Lowercase letters and Uppercase letters.




ctype.h 提供了一些函数用于测试和映射字符。 这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。如果参数 c 满足描述的条件，则这些函数返回非零（true），若不满足描述的条件，则返回零（false）。

1.  int isalnum(int c):  检查所传的字符是否是字母和数字。
2.  int isalpha(int c):  检查所传的字符是否是字母。
3.  int iscntrl(int c):  检查所传的字符是否是控制字符。
4.  int isdigit(int c):  检查所传的字符是否是十进制数字。
5.  int isgraph(int c):  检查所传的字符是否有图形表示法。
6.  int islower(int c):  检查所传的字符是否是小写字母。
7.  int isprint(int c):  检查所传的字符是否是可打印的。
8.  int ispunct(int c):  检查所传的字符是否是标点符号字符。
9.  int isspace(int c):  检查所传的字符是否是空白字符。
10. int isupper(int c):  检查所传的字符是否是大写字母。
11. int isxdigit(int c): 检查所传的字符是否是十六进制数字。
12.	int tolower(int c):  把大写字母转换为小写字母。
13.	int toupper(int c):  把小写字母转换为大写字母。

1	数字:         完整的数字集合 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
2	十六进制数字:  集合 { 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f }
3	小写字母:      集合 { a b c d e f g h i j k l m n o p q r s t u v w x y z }
4	大写字母:      集合 {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z }
5	字母:         小写字母和大写字母的集合
6	字母数字字符:  数字、小写字母和大写字母的集合
7	标点符号字符:  集合 ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
8	图形字符:      字母数字字符和标点符号字符的集合
9	空格字符:      制表符、换行符、垂直制表符、换页符、回车符、空格符的集合。
10	可打印字符:    字母数字字符、标点符号字符和空格字符的集合。
11	控制字符:      在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）。
12	空白字符:      包括空格符和制表符。
13	字母字符:      小写字母和大写字母的集合。

 //https://www.cnblogs.com/hibernate6/archive/2011/10/29/2522003.html
<ctype.h>主要提供两类重要的函数：字符测试函数和字符大小转化函数。提供的函数中都以int类型为参数，并返回一个int类型的值。实参类型应该隐式转换或者显示转换为int类型。
1 字符测试函数
　　1> 函数原型均为int isxxxx(int)
　　2> 参数为int, 任何实参均被提升成整型
　　3> 只能正确处理处于[0, 127]之间的值
2 字符映射函数
　　1> 函数原型为int toxxxx(int)
　　2> 对参数进行检测, 若符合范围则转换, 否则不变
　　int tolower(int); 'A'~'Z' ==> 'a'~'z'
　　int toupper(int); 'a'~'z' ==> 'A'~'Z'




=======================================================================
<errno.h>

The header file defines the integer variable 'errno', which is set by system calls and some library functions in the event of an error to indicate what went wrong. This macro expands to a modifiable 'lvalue' of type int, therefore it can be both read and modified by a program. The errno is set to zero at program startup. Certain functions of the standard C library modify its value to other than zero to signal some types of error. You can also modify its value or reset to zero at your convenience.

The header file also defines a list of macros indicating different error codes, which will expand to integer constant expressions with type int.


Library Macros
1. extern int 'errno':   This is the macro set by system calls and some library functions in the event of an error to indicate what went wrong.
2. 'EDOM' Domain Error:  This macro represents a domain error, which occurs if an input argument is outside the domain, over which the mathematical function is defined and errno is set to EDOM.
3. 'ERANGE' Range Error: This macro represents a range error, which occurs if an input argument is outside the range, over which the mathematical function is defined and errno is set to ERANGE.


errno.h定义了整数变量 errno，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为 int 的可更改的左值，因此它可以被一个程序读取和修改。
在程序启动时，errno 设置为零，C 标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。 errno.h定义了一系列表示不同错误代码的宏，这些宏应扩展为类型为 int 的整数常量表达式。

1	extern int errno：    这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。
2	EDOM Domain Error：   这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。
3	ERANGE Range Error：  这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE。


//https://www.cnblogs.com/haomiao/p/6128556.html
//http://www.cnblogs.com/cainiaoaixuexi/p/3478375.html
errno.h 提供了一个整数全局变量errno，当系统调用或者库函数的错误事件发生时可能会修改该值，指明错误的原因，该值可在任何需要的地方被修改；
一般情况不为0的值表示出现了异常或者错误。 errno.h中定义了一系列的错误代码，以E开头的宏。

glibc 中 'extern int errno' 来声明定义该错误值；此外其他的E开头的宏EDOM、EILSEQ、ERANGE、EOWNERDEAD等。
不同的标准库实现的以E开头的宏，可能有不同的定义值，甚至有不同的宏名称；可根据需要查看各个平台的错误码定义说明；
在现实应用中应尽量不要依赖于errno值，因为很可能当调用某个函数失败后，检查该值时，其值有可能又被其他函数给修改了，不过有时候对于检查问题的原因还是有用的。

=======================================================================
<float.h>

The header file contains a set of various platform-dependent constants related to floating point values. These constants are proposed by ANSI C. They allow making more portable programs. Before checking all the constants, it is good to understand that floating-point number is composed of following four elements:
1. S: sign ( +/- )
2. b: base or radix of the exponent representation, 2 for binary, 10 for decimal, 16 for hexadecimal, and so on...
3. e: exponent, an integer between a minimum 'Emin' and a maximum 'Emax'.
4. p: precision, the number of base-b digits in the significand

Based on the above 4 components, a floating point will have its value as follows:
"floating-point = ( S ) p x b^{e}" or "floating-point = (+/-) precision x base^{exponent}"


Library Macros
FLT refers to type float, DBL refers to double, and LDBL refers to long double.

1. FLT_ROUNDS: Defines the rounding mode for floating point addition and it can have any of the following values: (1) -1 - indeterminable, (2) 0 - towards zero
2. FLT_RADIX 2: 
3. FLT_MANT_DIG, DBL_MANT_DIG, LDBL_MANT_DIG: 
4. FLT_MANT_DIG, DBL_MANT_DIG, LDBL_MANT_DIG: 
5. FLT_MIN_EXP,  DBL_MIN_EXP,  LDBL_MIN_EXP: 
6. FLT_MIN_10_EXP -37, DBL_MIN_10_EXP -37, LDBL_MIN_10_EXP -37: 
7. FLT_MAX_EXP, DBL_MAX_EXP, LDBL_MAX_EXP: 
8. FLT_MAX_10_EXP +37, DBL_MAX_10_EXP +37, LDBL_MAX_10_EXP +37: 
9. FLT_MAX 1E+37, DBL_MAX 1E+37, LDBL_MAX 1E+37: 
10. FLT_EPSILON 1E-5, DBL_EPSILON 1E-9, LDBL_EPSILON 1E-9: 
11. FLT_MIN 1E-37, DBL_MIN 1E-37, LDBL_MIN 1E-37:



float.h 头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。在讲解这些常量之前，最好先弄清楚浮点数是由下面四个元素组成的：
S	符号 ( +/- )
b	指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等...
e	指数，一个介于最小值 emin 和最大值 emax 之间的整数。
p	精度，基数 b 的有效位数

基于以上 4 个组成部分，一个浮点数的值如下：floating-point = ( S ) p*b^{e} 或 floating-point = (+/-) precision*base^{exponent}

1. FLT_ROUNDS:                                       定义浮点加法的舍入模式，它可以是下列任何一个值： (1) -1 无法确定, (2) 0 趋向于零, (3) 1 趋向于最近的值, (4) 2 趋向于正无穷,(5) 3 趋向于负无穷
2. FLT_RADIX 2:                                      这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。
3. FLT_MANT_DIG; DBL_MANT_DIG; LDBL_MANT_DIG:        这些宏定义了 FLT_RADIX 基数中的位数。
4. FLT_DIG 6; DBL_DIG 10; LDBL_DIG 10:               这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。
5. FLT_MIN_EXP; DBL_MIN_EXP; LDBL_MIN_EXP:           这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。
6. FLT_MIN_10_EXP -37; DBL_MIN_10_EXP -37; LDBL_MIN_10_EXP -37:   这些宏定义了基数为 10 时的指数的最小负整数值。
7. FLT_MAX_EXP; DBL_MAX_EXP; LDBL_MAX_EXP:           这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。
8. FLT_MAX_10_EXP +37; DBL_MAX_10_EXP +37; LDBL_MAX_10_EXP +37:   这些宏定义了基数为 10 时的指数的最大整数值。
9. FLT_MAX 1E+37; DBL_MAX 1E+37; LDBL_MAX 1E+37:     这些宏定义最大的有限浮点值。
10.FLT_EPSILON 1E-5; DBL_EPSILON 1E-9; LDBL_EPSILON 1E-9: 这些宏定义了可表示的最小有效数字。
11.FLT_MIN 1E-37; DBL_MIN 1E-37; LDBL_MIN 1E-37:     这些宏定义了最小的浮点值。

float.h 内部主要包含了一系列的浮点数宏、指明可移植程序必要的常量；浮点数格式一般为Spbe;其中S表示+-；p表示底数、b表示基数如2、8、10、16等进制，e为指数标识E或e；在一般情况下可以直接使用该头文件中宏定义的值。

//http://www.cnblogs.com/ywl925/p/3707736.html
由于浮点数存在的精度误差，造成浮点数与0比较的问题，一般定义其误差值来解决。float.h中已经定义了float,double两种浮点数的误差值，用户可以直接使用。

//https://www.cnblogs.com/todsong/archive/2010/11/16/1878849.html
C语言的数据类型有四种：整形、浮点型、指针、聚合类型（数组、结构等），其中整形家族的变量包括：char, int, short, long, enum等。浮点数家族包括float, double等。
limits.h头文件对整形家族变量范围进行了宏定义。float.h定义了FLT_MAX, FLT_MIN, DBL_MAX, DBL_MIN。


=======================================================================
<limits.h>

The header determines various properties of the various variable types. The macros defined in this header, limits the values of various variable types like char, int and long. These limits specify that a variable cannot store any value beyond these limits, for example an unsigned character can store up to a maximum value of 255.


Library Macros
1. CHAR_BIT      8               Defines the number of bits in a byte.
2. SCHAR_MIN    -128             Defines the minimum value for a signed char.
3. SCHAR_MAX     127             Defines the maximum value for a signed char.
4. UCHAR_MAX     255             Defines the maximum value for an unsigned char.
5. CHAR_MIN      0               Defines the minimum value for type char and its value will be equal to SCHAR_MIN if char represents negative values, otherwise zero.
6. CHAR_MAX      127             Defines the value for type char and its value will be equal to SCHAR_MAX if char represents negative values, otherwise UCHAR_MAX.
7. MB_LEN_MAX    1               Defines the maximum number of bytes in a multi-byte character.
8. SHRT_MIN     -32768           Defines the minimum value for a short int
9. SHRT_MAX     +32767           Defines the maximum value for a short int.
10.USHRT_MAX     65535           Defines the maximum value for an unsigned short int.
11.INT_MIN      -32768           Defines the minimum value for an int.
12.INT_MAX      +32767           Defines the maximum value for an int.
13.UINT_MAX      65535           Defines the maximum value for an unsigned int.
14.LONG_MIN     -2147483648      Defines the minimum value for a long int.
15.LONG_MAX     +2147483647      Defines the maximum value for a long int.
16.ULONG_MAX     4294967295      Defines the maximum value for an unsigned long int.


limits.h 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。 这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。
CHAR_BIT       8                 定义一个字节的比特数。
SCHAR_MIN     -128               定义一个有符号字符的最小值。
SCHAR_MAX      127               定义一个有符号字符的最大值。
UCHAR_MAX      255               定义一个无符号字符的最大值。
CHAR_MIN       0                 定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于 0。
CHAR_MAX       127               定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于 UCHAR_MAX。
MB_LEN_MAX     1                 定义多字节字符中的最大字节数。
SHRT_MIN      -32768             定义一个短整型的最小值。
SHRT_MAX      +32767             定义一个短整型的最大值。
USHRT_MAX      65535             定义一个无符号短整型的最大值。
INT_MIN       -32768             定义一个整型的最小值。
INT_MAX       +32767             定义一个整型的最大值。
UINT_MAX       65535             定义一个无符号整型的最大值。
LONG_MIN      -2147483648        定义一个长整型的最小值。
LONG_MAX      +2147483647        定义一个长整型的最大值。
ULONG_MAX      4294967295        定义一个无符号长整型的最大值。


//https://www.cnblogs.com/lzhu/p/4706229.html
limits.h定义了用于表示整类型大小的常量。以下所列的值是可接受的最小值，实际系统中可能有更大的值。

CHAR_BIT 	8                       char类型的位数
CHAR_MAX 	UCHAR_MAX或SCHAR_MAX    char类型的最大值
CHAR_MIN 	0或SCHAR_MIN            char类型的最小值
INT_MAX 	32767                   int类型的最大值
INT_MIN 	-32767                  int类型的最小值
LONG_MAX 	2147483647              long的最大值
LONG_MIN 	-2147483647             long类型的最小值
SCHAR_MAX 	+127                    signed char类型的最大值
SCHAR_MIN 	-127                    signed char类型的最小值
SHRT_MAX 	+32767                  short类型的最大值
SHRT_MIN 	-32767                  short类型的最小值
UCHAR_MAX 	255                     unsigned char类型的最大值
UINT_MAX 	65535                   unsigned int类型的最大值
ULONG_MAX 	4294967295              unsigned long的最大值
USHRT_MAX 	65535                   unsigned short的最大值


=======================================================================
<locale.h>

The header file defines the location specific settings, such as date formats and currency symbols. You will find several macros defined along with an important structure "struct lconv" and two important functions.


Library Macros
1. LC_ALL:       Sets everything.
2. LC_COLLATE:   Affects strcoll and strxfrm functions.
3. LC_CTYPE:     Affects all character functions.
4. LC_MONETARY:  Affects the monetary information provided by localeconv function.
5. LC_NUMERIC:   Affects decimal-point formatting and the information provided by localeconv function.
6. LC_TIME:      Affects the strftime function.

Functions
1. char *setlocale(int category, const char *locale): Sets or reads location dependent information.
2. struct lconv *localeconv(void):                    Sets or reads location dependent information.

typedef struct {
	char *decimal_point;      // Decimal point character used for non-monetary values.
	char *thousands_sep;      // Thousands place separator character used for non-monetary values
	char *grouping;           // A string that indicates the size of each group of digits in non-monetary quantities.
	char *int_curr_symbol;    // It is a string of the international currency symbols used.
	char *currency_symbol;    // The local symbol used for currency.
	char *mon_decimal_point;  // The decimal point character used for monetary values.
	char *mon_thousands_sep;  // The thousands place grouping character used for monetary values.
	char *mon_grouping;       // A string whose elements defines the size of the grouping of digits in monetary values.
	char *positive_sign;      // The character used for positive monetary values.
	char *negative_sign;      // The character used for negative monetary values.
	char int_frac_digits;     // Number of digits to show after the decimal point in international monetary values.
	char frac_digits;         // Number of digits to show after the decimal point in monetary values.
	char p_cs_precedes;       // If equals to 1, then the currency_symbol appears before a positive monetary value. 
	char p_sep_by_space;      // If equals to 1, then the currency_symbol is separated by a space from a positive monetary value.
	char n_cs_precedes;       // If equals to 1, then the currency_symbol precedes a negative monetary value.
	char n_sep_by_space;      // If equals to 1, then the currency_symbol is separated by a space from a negative monetary value.
	char p_sign_posn;         // Represents the position of the positive_sign in a positive monetary value. (take values in 0~4)
	char n_sign_posn;         // Represents the position of the negative_sign in a negative monetary value. (take values in 0~4)
} lconv



//https://www.cnblogs.com/Mr-Wenyan/p/7218155.html
locale.h定义了特定地域的设置，如日期格式和货币符号。它声明了两个函数和一个类型，并且定义了一些宏。

1. LC_ALL：      设置下面的所有选项。
2. LC_COLLATE：  影响 strcoll 和 strxfrm 函数。
3. LC_CTYPE：    影响所有字符函数。
4. LC_MONETARY： 影响 localeconv 函数提供的货币信息。
5. LC_NUMERIC：  影响 localeconv 函数提供的小数点格式化和信息。
6. LC_TIME：     影响 strftime 函数。


1. char *setlocale(int category, const char *locale): 设置或读取地域化信息。
2. struct lconv *localeconv(void):                    设置或读取地域化信息。

typedef struct {
   char *decimal_point;     //用于非货币值的小数点字符
   char *thousands_sep;     //用于非货币值的千位分隔符
   char *grouping;          //一个表示非货币量中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。
   char *int_curr_symbol;   //国际货币符号使用的字符串。前三个字符是由 ISO 4217:1987 指定的，第四个字符用于分隔货币符号和货币量
   char *currency_symbol;   //用于货币的本地符号
   char *mon_decimal_point; //用于货币值的小数点字符
   char *mon_thousands_sep; //用于货币值的千位分隔符
   char *mon_grouping;      //一个表示货币值中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组
   char *positive_sign;     //用于正货币值的字符
   char *negative_sign;     //用于负货币值的字符
   char int_frac_digits;    //国际货币值中小数点后要显示的位数
   char frac_digits;        //货币值中小数点后要显示的位数
   char p_cs_precedes;      //如果等于 1，则 currency_symbol 出现在正货币值之前。如果等于 0，则 currency_symbol 出现在正货币值之后
   char p_sep_by_space;     //如果等于 1，则 currency_symbol 和正货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和正货币值之间不使用空格分隔。
   char n_cs_precedes;      //如果等于 1，则 currency_symbol 出现在负货币值之前。如果等于 0，则 currency_symbol 出现在负货币值之后。
   char n_sep_by_space;     //如果等于 1，则 currency_symbol 和负货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和负货币值之间不使用空格分隔。
   char p_sign_posn;        //表示正货币值中正号的位置。
   char n_sign_posn;        //表示负货币值中负号的位置。
} lconv

下面的值用于 p_sign_posn 和 n_sign_posn:
0 	封装值和 currency_symbol 的括号。
1 	放置在值和 currency_symbol 之前的符号。
2 	放置在值和 currency_symbol 之后的符号。
3 	紧挨着放置在值和 currency_symbol 之前的符号。
4 	紧挨着放置在值和 currency_symbol 之后的符号。


=======================================================================
<match.h>

The header defines various mathematical functions and one macro. All the functions take double as an argument and return double as the result.

Library Macros
1. HUGE_VAL: 
This macro is used when the result of a function may not be representable as a floating point number. If magnitude of the correct result is too large to be represented, the function sets errno to ERANGE to indicate a range error, and returns a particular, very large value named by the macro HUGE_VAL or its negation (- HUGE_VAL).
If the magnitude of the result is too small, a value of zero is returned instead. In this case, errno might or might not be set to ERANGE.



Functions
1. double acos(double x)                    : Returns the arc cosine of x in radians.
2. double asin(double x)                    : Returns the arc sine of x in radians.
3. double atan(double x)                    : Returns the arc tangent of x in radians.
4. double atan2(doubly y, double x)         : Returns the arc tangent in radians of y/x based on the signs of both values to determine the correct quadrant.
5. double cos(double x)                     : Returns the cosine of a radian angle x.
6. double cosh(double x)                    : Returns the hyperbolic cosine of x.
7. double sin(double x)                     : Returns the sine of a radian angle x.
8. double sinh(double x)                    : Returns the hyperbolic sine of x.
9. double tanh(double x)                    : Returns the hyperbolic tangent of x.
10.double exp(double x)                     : Returns the value of e raised to the xth power.
11.double frexp(double x, int *exponent)    : The returned value is the mantissa and the integer pointed to by exponent is the exponent. The result is x = mantissa*2^exponent.
12.double ldexp(double x, int exponent)     : Returns x multiplied by 2 raised to the power of exponent.
13.double log(double x)                     : Returns the natural logarithm (base-e logarithm) of x.
14.double log10(double x)                   : Returns the common logarithm (base-10 logarithm) of x.
15.double modf(double x, double *integer)   : The returned value is the fraction component (part after the decimal), and sets integer to the integer component.
16.double pow(double x, double y)           : Returns x raised to the power of y.
17.double sqrt(double x)                    : Returns the square root of x.
18.double ceil(double x)                    : Returns the smallest integer value greater than or equal to x.
19.double fabs(double x)                    : Returns the absolute value of x.
20.double floor(double x)                   : Returns the largest integer value less than or equal to x.
21.double fmod(double x, double y)          : Returns the remainder of x divided by y.


math.h定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 double 类型的参数，且都返回 double 类型的结果

1. HUGE_VAL：
当函数的结果不可以表示为浮点数时。如果是因为结果的幅度太大以致于无法表示，则函数会设置 errno 为 ERANGE 来表示范围错误，并返回一个由宏 HUGE_VAL 或者它的否定（- HUGE_VAL）命名的一个特定的很大的值。如果结果的幅度太小，则会返回零值。在这种情况下，error 可能会被设置为 ERANGE，也有可能不会被设置为 ERANGE。


1.  double acos(double x):                   返回以弧度表示的 x 的反余弦
2.  double asin(double x):                   返回以弧度表示的 x 的反正弦
3.  double atan(double x):                   返回以弧度表示的 x 的反正切
4.  double atan2(double y, double x):        返回以弧度表示的 y/x 的反正切y 和 x 的值的符号决定了正确的象限
5.  double cos(double x):                    返回弧度角 x 的余弦
6.  double cosh(double x):                   返回 x 的双曲余弦
7.  double sin(double x):                    返回弧度角 x 的正弦
8.  double sinh(double x):                   返回 x 的双曲正弦
9.  double tanh(double x):                   返回 x 的双曲正切
10. double exp(double x):                    返回 e 的 x 次幂的值
11. double frexp(double x, int *exponent):   把浮点数 x 分解成尾数和指数返回值是尾数，并将指数存入 exponent 中所得的值是 x = mantissa * 2 ^ exponent
12. double ldexp(double x, int exponent):    返回 x 乘以 2 的 exponent 次幂
13. double log(double x):                    返回 x 的自然对数（基数为 e 的对数）
14. double log10(double x):                  返回 x 的常用对数（基数为 10 的对数）
15. double modf(double x, double *integer):  返回值为小数部分（小数点后的部分），并设置 integer 为整数部分
16. double pow(double x, double y):          返回 x 的 y 次幂
17. double sqrt(double x):                   返回 x 的平方根
18. double ceil(double x):                   返回大于或等于 x 的最小的整数值
19. double fabs(double x):                   返回 x 的绝对值
20. double floor(double x):                  返回小于或等于 x 的最大的整数值
21. double fmod(double x, double y):         返回 x 除以 y 的余数






=======================================================================
<setjmp.h>

The header defines the macro 'setjmp()', one function 'longjmp()', and one variable type 'jmp_buf', for bypassing the normal function call and return discipline.


Library Variables
1. jmp_buf:  This is an array type used for holding information for macro setjmp() and function longjmp().

Library Macros
1. int setjmp(jmp_buf environment):   This macro saves the current environment into the variable 'environment' for the function longjmp(). If this macro returns directly from the macro invocation, it returns zero but if it returns from a longjmp() function call, then a non-zero value is returned.

Library Functions
1. void longjmp(jmp_buf environment, int value): This function restores the environment saved by the most recent call to setjmp() macro in the same invocation of the program with the corresponding jmp_buf argument.



setjmp.h定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则。
1. jmp_buf:                                      这是一个用于存储宏 setjmp() 和函数 longjmp() 相关信息的数组类型
1. int setjmp(jmp_buf environment):              这个宏把当前环境保存在变量 environment 中，以便函数 longjmp() 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 longjmp() 函数调用中返回，则它会返回一个非零值。
1. void longjmp(jmp_buf environment, int value): 该函数恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的。






=======================================================================
<signal.h>

The header defines a variable type 'sig_atomic_t', two function calls, and several macros to handle different signals reported during a program's execution.

Library Variables
1. sig_atomic_t: This is of int type and used as a variable in a signal handler. This is an integral type of an object that can be accessed as an atomic entity, even in the presence of asynchronous signals.

Library Macros
The SIG_ macros are used with the signal function to define signal functions.
1. SIG_DFL:    Default signal handler.
2. SIG_ERR:    Represents a signal error.
3. SIG_IGN:    Signal ignore.

The SIG macros are used to represent a signal number
1. SIGABRT:    Abnormal program termination.
2. SIGFPE:     Floating-point error like division by zero.
3. SIGILL:     Illegal operation.
4. SIGINT:     Interrupt signal such as ctrl-C.
5. SIGSEGV:    Invalid access to storage like segment violation.
6. SIGTERM:    Termination request.


Library Functions
1. void (*signal(int sig, void (*func)(int)))(int):  This function sets a function to handle signal i.e. a signal handler.
2. int raise(int sig):                               This function causes signal sig to be generated. The sig argument is compatible with the SIG macros.



signal.h定义了一个变量类型 sig_atomic_t、两个函数调用和一些宏来处理程序执行期间报告的不同信号。

1. sig_atomic_t: 这是 int 类型，在信号处理程序中作为变量使用。它是一个对象的整数类型，该对象可以作为一个原子实体访问，即使存在异步信号时，该对象可以作为一个原子实体访问。

SIG_ 宏与 signal 函数一起使用来定义信号的功能。
1. SIG_DFL:      默认的信号处理程序。
2. SIG_ERR:      表示一个信号错误。
3. SIG_IGN:      忽视信号。

SIG 宏用于表示以下各种条件的信号码：
1. SIGABRT: 程序异常终止。
2. SIGFPE:  算术运算出错，如除数为 0 或溢出。
3. SIGILL:  非法函数映象，如非法指令。
4. SIGINT:  中断信号，如 ctrl-C。
5. SIGSEGV: 非法访问存储器，如访问不存在的内存单元。
6. SIGTERM: 发送给本程序的终止请求信号。

1. void (*signal(int sig, void (*func)(int)))(int): 该函数设置一个函数来处理信号，即信号处理程序。
2. int raise(int sig):                              该函数会促使生成信号 sig。sig 参数与 SIG 宏兼容。

=======================================================================
<stdarg.h>

The header defines a variable type 'va_list' and three macros which can be used to get the arguments in a function when the number of arguments are not known i.e. variable number of arguments.
A function of variable arguments is defined with the ellipsis (,...) at the end of the parameter list.


Library Variables
1. va_list: This is a type suitable for holding information needed by the three macros va_start(), va_arg() and va_end().


Library Macros
1. void va_start(va_list ap, last_arg):   This macro initializes ap with the va_arg and va_end macros. The last_arg is the last known fixed argument being passed to the function i.e. the argument before the ellipsis.
2. type va_arg(va_list ap, type):         This macro retrieves the next argument in the parameter list of the function with type type.
3. void va_end(va_list ap):               This macro allows a function with variable arguments which used the va_start macro to return. If va_end is not called before returning from the function, the result is undefined.



stdarg.h 定义了一个变量类型 va_list 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。可变参数的函数通在参数列表的末尾是使用省略号(,...)定义的。

1. va_list: 这是一个适用于 va_start()、va_arg() 和 va_end() 这三个宏存储信息的类型。

1. void va_start(va_list ap, last_arg): 这个宏初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。
2. type va_arg(va_list ap, type):       这个宏检索函数参数列表中类型为 type 的下一个参数。
3. void va_end(va_list ap):             这个宏允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义。

=======================================================================
<stddef.h>

The header defines various variable types and macros. Many of these definitions also appear in other headers.


Library Variables
1. ptrdiff_t:    This is the signed integral type and is the result of subtracting two pointers.
2. size_t:       This is the unsigned integral type and is the result of the sizeof keyword.
3. wchar_t:      This is an integral type of the size of a wide character constant.


Library Macros
1. NULL:                                 This macro is the value of a null pointer constant.
2. offsetof(type, member-designator):    This results in a constant integer of type size_t which is the offset in bytes of a structure member from the beginning of the structure. The member is given by member-designator, and the name of the structure is given in type.


stddef .h定义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中
1. ptrdiff_t:   这是有符号整数类型，它是两个指针相减的结果。
2. size_t:      这是无符号整数类型，它是 sizeof 关键字的结果。
3. wchar_t:     这是一个宽字符常量大小的整数类型。

1. NULL:        这个宏是一个空指针常量的值。
2. offsetof(type, member-designator):  这会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的。

=======================================================================
<stdio.h>

The header defines three variable types, several macros, and various functions for performing input and output.


Library Variables
1. size_t:  This is the unsigned integral type and is the result of the sizeof keyword.
2. FILE:    This is an object type suitable for storing information for a file stream.
3. fpos_t:  This is an object type suitable for storing any position in a file.


Library Macros
1. NULL:                                  This macro is the value of a null pointer constant.
2. _IOFBF, _IOLBF and _IONBF:             These are the macros which expand to integral constant expressions with distinct values and suitable for the use as third argument to the setvbuf function.
3. BUFSIZ:                                This macro is an integer, which represents the size of the buffer used by the setbuf function.
4. EOFM:                                  This macro is a negative integer, which indicates that the end-of-file has been reached.
5. FOPEN_MAX:                             This macro is an integer, which represents the maximum number of files that the system can guarantee to be opened simultaneously.
6. FILENAME_MAX:                          This macro is an integer, which represents the longest length of a char array suitable for holding the longest possible filename.
7. L_tmpnam:                              This macro is an integer, which represents the longest length of a char array suitable for holding the longest possible temporary filename created by the tmpnam function.
8. SEEK_CUR, SEEK_END, and SEEK_SET:      These macros are used in the fseek function to locate different positions in a file.
9. TMP_MAX:                               This macro is the maximum number of unique filenames that the function tmpnam can generate.
10. stderr, stdin, and stdout:            These macros are pointers to FILE types which correspond to the standard error, standard input, and standard output streams.



Library Functions
1. int fclose(FILE *stream):                                                 Closes the stream. All buffers are flushed.
2. void clearerr(FILE *stream):                                              Clears the end-of-file and error indicators for the given stream.
3. int feof(FILE *stream):                                                   Tests the end-of-file indicator for the given stream.
4.int ferror(FILE *stream):                                                  Tests the error indicator for the given stream.
5. int fflush(FILE *stream):                                                 Flushes the output buffer of a stream.
6. int fgetpos(FILE *stream, fpos_t *pos):                                   Gets the current file position of the stream and writes it to pos.
7. FILE *fopen(const char *filename, const char *mode):                      Opens the filename pointed to by filename using the given mode.
8. size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream):         Reads data from the given stream into the array pointed to by ptr.
9. FILE *freopen(const char *filename, const char *mode, FILE *stream):      Associates a new filename with the given open stream and same time closing the old file in stream.
10. int fseek(FILE *stream, long int offset, int whence):                    Sets the file position of the stream to the given offset. The argument offset signifies the number of bytes to seek from the given whence position.
11. int fsetpos(FILE *stream, const fpos_t *pos):                            Sets the file position of the given stream to the given position. The argument pos is a position given by the function fgetpos.
12. long int ftell(FILE *stream):                                            Returns the current file position of the given stream
13. size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream): Writes data from the array pointed to by ptr to the given stream.
14. int remove(const char *filename):                                        Deletes the given filename so that it is no longer accessible.
15. int rename(const char *old_filename, const char *new_filename):          Causes the filename referred to, by old_filename to be changed to new_filename.
16. void rewind(FILE *stream):                                               Sets the file position to the beginning of the file of the given stream.
17. void setbuf(FILE *stream, char *buffer):                                 Defines how a stream should be buffered.
18. int setvbuf(FILE *stream, char *buffer, int mode, size_t size):          Another function to define how a stream should be buffered.
19. FILE *tmpfile(void):                                                     Creates a temporary file in binary update mode (wb+).
20. char *tmpnam(char *str):                                                 Generates and returns a valid temporary filename which does not exist.
21. int fprintf(FILE *stream, const char *format, ...):                      Sends formatted output to a stream.
22. int printf(const char *format, ...):                                     Sends formatted output to stdout.
23. int sprintf(char *str, const char *format, ...):                         Sends formatted output to a string.
24. int vfprintf(FILE *stream, const char *format, va_list arg):             Sends formatted output to a stream using an argument list
25. int vprintf(const char *format, va_list arg):                            Sends formatted output to stdout using an argument list.
26. int vsprintf(char *str, const char *format, va_list arg):                Sends formatted output to a string using an argument list.
27. int fscanf(FILE *stream, const char *format, ...):                       Reads formatted input from a stream.
28. int scanf(const char *format, ...):                                      Reads formatted input from stdin.
29. int sscanf(const char *str, const char *format, ...):                    Reads formatted input from a string.
30. int fgetc(FILE *stream):                                                 Gets the next character (an unsigned char) from the specified stream and advances the position indicator for the stream.
31. char *fgets(char *str, int n, FILE *stream):                             Reads a line from the specified stream and stores it into the string pointed to by str. It stops when either (n-1) characters are read, the newline character is read, or the end-of-file is reached, whichever comes first.
32. int fputc(int char, FILE *stream):                                       Writes a character (an unsigned char) specified by the argument char to the specified stream and advances the position indicator for the stream.
33. int fputs(const char *str, FILE *stream):                                Writes a string to the specified stream up to but not including the null character.
34. int getc(FILE *stream):                                                  Gets the next character (an unsigned char) from the specified stream and advances the position indicator for the stream.
35. int getchar(void):                                                       Gets a character (an unsigned char) from stdin
36. char *gets(char *str):                                                   Reads a line from stdin and stores it into the string pointed to, by str. It stops when either the newline character is read or when the end-of-file is reached, whichever comes first.
37. int putc(int char, FILE *stream):                                        Writes a character (an unsigned char) specified by the argument char to the specified stream and advances the position indicator for the stream.
38. int putchar(int char):                                                   Writes a character (an unsigned char) specified by the argument char to stdout.
39. int puts(const char *str):                                               Writes a string to stdout up to but not including the null character. A newline character is appended to the output.
40. int ungetc(int char, FILE *stream):                                      Pushes the character char (an unsigned char) onto the specified stream so that the next character is read.
41. void perror(const char *str):                                            Prints a descriptive error message to stderr. First the string str is printed followed by a colon and then a space




stdio .h 头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。


1. size_t: 这是无符号整数类型，它是 sizeof 关键字的结果。
2. FILE:   这是一个适合存储文件流信息的对象类型。
3. fpos_t: 这是一个适合存储文件中任何位置的对象类型。


1. NULL:                          这个宏是一个空指针常量的值。
2. _IOFBF、_IOLBF 和 _IONBF:       这些宏扩展了带有特定值的整型常量表达式，并适用于 setvbuf 函数的第三个参数。
3. BUFSIZ:                        这个宏是一个整数，该整数代表了 setbuf 函数使用的缓冲区大小。
4. EOF:                           这个宏是一个表示已经到达文件结束的负整数。
5. FOPEN_MAX:                     这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。
6. FILENAME_MAX:                  这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。
7. L_tmpnam:                      这个宏是一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度。
8. SEEK_CUR、SEEK_END 和 SEEK_SET: 这些宏是在These macros are used in the fseek 函数中使用，用于在一个文件中定位不同的位置。
9. TMP_MAX:                       这个宏是 tmpnam 函数可生成的独特文件名的最大数量。
10. stderr、stdin 和 stdout:       这些宏是指向 FILE 类型的指针，分别对应于标准错误、标准输入和标准输出流。


1.  int fclose(FILE *stream):                                                      关闭流 stream。刷新所有的缓冲区。
2.  void clearerr(FILE *stream):                                                   清除给定流 stream 的文件结束和错误标识符。
3.  int feof(FILE *stream):                                                        测试给定流 stream 的文件结束标识符。
4.  int ferror(FILE *stream):                                                      测试给定流 stream 的错误标识符。
5.  int fflush(FILE *stream):                                                      刷新流 stream 的输出缓冲区。
6.  int fgetpos(FILE *stream, fpos_t *pos):                                        获取流 stream 的当前文件位置，并把它写入到 pos。
7.  FILE *fopen(const char *filename, const char *mode):                           使用给定的模式 mode 打开 filename 所指向的文件。
8.  size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream):              从给定流 stream 读取数据到 ptr 所指向的数组中。
9.  FILE *freopen(const char *filename, const char *mode, FILE *stream):           把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。
10. int fseek(FILE *stream, long int offset, int whence):                          设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。
11. int fsetpos(FILE *stream, const fpos_t *pos):                                  设置给定流 stream 的文件位置为给定的位置。参数 pos 是由函数 fgetpos 给定的位置。
12. long int ftell(FILE *stream):                                                  返回给定流 stream 的当前文件位置。
13. size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream):       把 ptr 所指向的数组中的数据写入到给定流 stream 中。
14. int remove(const char *filename):                                              删除给定的文件名 filename，以便它不再被访问。
15. int rename(const char *old_filename, const char *new_filename):                把 old_filename 所指向的文件名改为 new_filename。
16. void rewind(FILE *stream):                                                     设置文件位置为给定流 stream 的文件的开头。
17. void setbuf(FILE *stream, char *buffer):                                       定义流 stream 应如何缓冲。
18. int setvbuf(FILE *stream, char *buffer, int mode, size_t size):                另一个定义流 stream 应如何缓冲的函数。
19. FILE *tmpfile(void):                                                           以二进制更新模式(wb+)创建临时文件。
20. char *tmpnam(char *str):                                                       生成并返回一个有效的临时文件名，该文件名之前是不存在的。
21. int fprintf(FILE *stream, const char *format, ...):                            发送格式化输出到流 stream 中。
22. int printf(const char *format, ...):                                           发送格式化输出到标准输出 stdout。
23. int sprintf(char *str, const char *format, ...):                               发送格式化输出到字符串。
24. int vfprintf(FILE *stream, const char *format, va_list arg):                   使用参数列表发送格式化输出到流 stream 中。
25. int vprintf(const char *format, va_list arg):                                  使用参数列表发送格式化输出到标准输出 stdout。
26. int vsprintf(char *str, const char *format, va_list arg):                      使用参数列表发送格式化输出到字符串。
27. int fscanf(FILE *stream, const char *format, ...):                             从流 stream 读取格式化输入。
28. int scanf(const char *format, ...):                                            从标准输入 stdin 读取格式化输入。
29. int sscanf(const char *str, const char *format, ...):                          从字符串读取格式化输入。
30. int fgetc(FILE *stream):                                                       从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。
31. char *fgets(char *str, int n, FILE *stream):                                   从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。
32. int fputc(int char, FILE *stream):                                             把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。
33. int fputs(const char *str, FILE *stream):                                      把字符串写入到指定的流 stream 中，但不包括空字符。
34. int getc(FILE *stream):                                                        从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。
35. int getchar(void):                                                             从标准输入 stdin 获取一个字符（一个无符号字符）。
36. char *gets(char *str):                                                         从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。
37. int putc(int char, FILE *stream):                                              把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。
38. int putchar(int char):                                                         把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。
39. int puts(const char *str):                                                     把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。
40. int ungetc(int char, FILE *stream):                                            把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。
41. void perror(const char *str):                                                  把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。


=======================================================================
<stdlib.h>

The header defines four variable types, several macros, and various functions for performing general functions.



Library Variables
1. size_t:   This is the unsigned integral type and is the result of the sizeof keyword.
2. wchar_t:  This is an integer type of the size of a wide character constant.
3. div_t:    This is the structure returned by the div function.
4. ldiv_t:   This is the structure returned by the ldiv function.


Library Macros
1. NULL:           This macro is the value of a null pointer constant.
2. EXIT_FAILURE:   This is the value for the exit function to return in case of failure.
3. EXIT_SUCCESS:   This is the value for the exit function to return in case of success.
4. RAND_MAX:       This macro is the maximum value returned by the rand function.
5. MB_CUR_MAX:     This macro is the maximum number of bytes in a multi-byte character set which cannot be larger than MB_LEN_MAX.


Library Functions
1. double atof(const char *str):                                        Converts the string pointed to, by the argument str to a floating-point number (type double).
2 int atoi(const char *str):                                            Converts the string pointed to, by the argument str to an integer (type int).
3 long int atol(const char *str):                                       Converts the string pointed to, by the argument str to a long integer (type long int).
4 double strtod(const char *str, char **endptr):                        Converts the string pointed to, by the argument str to a floating-point number (type double).
5 long int strtol(const char *str, char **endptr, int base):            Converts the string pointed to, by the argument str to a long integer (type long int).
6 unsigned long int strtoul(const char *str, char **endptr, int base):  Converts the string pointed to, by the argument str to an unsigned long integer (type unsigned long int).
7 void *calloc(size_t nitems, size_t size):                             Allocates the requested memory and returns a pointer to it.
8 void free(void *ptr):                                                 Deallocates the memory previously allocated by a call to calloc, malloc, orrealloc.
9 void *malloc(size_t size):                                            Allocates the requested memory and returns a pointer to it.
10 void *realloc(void *ptr, size_t size):                               Attempts to resize the memory block pointed to by ptr that was previously allocated with a call to malloc or calloc.
11 void abort(void):                                                    Causes an abnormal program termination.
12 int atexit(void (*func)(void)):                                      Causes the specified function func to be called when the program terminates normally.
13 void exit(int status):                                               Causes the program to terminate normally.
14 char *getenv(const char *name):                                      Searches for the environment string pointed to by name and returns the associated value to the string.
15 int system(const char *string):                                      The command specified by string is passed to the host environment to be executed by the command processor.
16 void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *)):    Performs a binary search.
17 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)):                               Sorts an array
18 int abs(int x):                                                       Returns the absolute value of x.
19 div_t div(int numer, int denom):                                      Divides numer (numerator) by denom (denominator).
20 long int labs(long int x):                                            Returns the absolute value of x.
21 ldiv_t ldiv(long int numer, long int denom):                          Divides numer (numerator) by denom (denominator).
22 int rand(void):                                                       Returns a pseudo-random number in the range of 0 to RAND_MAX.
23 void srand(unsigned int seed):                                        This function seeds the random number generator used by the function rand.
24 int mblen(const char *str, size_t n):                                 Returns the length of a multibyte character pointed to by the argument str.
25 size_t mbstowcs(schar_t *pwcs, const char *str, size_t n):            Converts the string of multibyte characters pointed to by the argument str to the array pointed to by pwcs.
26 int mbtowc(whcar_t *pwc, const char *str, size_t n):                  Examines the multibyte character pointed to by the argument str.
27 size_t wcstombs(char *str, const wchar_t *pwcs, size_t n):            Converts the codes stored in the array pwcs to multibyte characters and stores them in the string str.
28 int wctomb(char *str, wchar_t wchar):                                 Examines the code which corresponds to a multibyte character given by the argument wchar



stdlib.h 定义了四个变量类型、一些宏和各种通用工具函数

1. size_t:  这是无符号整数类型，它是 sizeof 关键字的结果。
2. wchar_t: 这是一个宽字符常量大小的整数类型。
3. div_t:   这是 div 函数返回的结构。
4. ldiv_t:  这是 ldiv 函数返回的结构。

1. NULL:          这个宏是一个空指针常量的值。
2. EXIT_FAILURE:  这是 exit 函数失败时要返回的值。
3. EXIT_SUCCESS:  这是 exit 函数成功时要返回的值。
4. RAND_MAX:      这个宏是 rand 函数返回的最大值。
5. MB_CUR_MAX:    这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX。

1.  double atof(const char *str):                                              把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。
2.  int atoi(const char *str):                                                 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。
3.  long int atol(const char *str):                                            把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。
4.  double strtod(const char *str, char **endptr):                             把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。
5.  long int strtol(const char *str, char **endptr, int base):                 把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。
6.  unsigned long int strtoul(const char *str, char **endptr, int base):       把参数 str 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。
7.  void *calloc(size_t nitems, size_t size):                                  分配所需的内存空间，并返回一个指向它的指针。
8.  void free(void *ptr):                                                      释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。
9.  void *malloc(size_t size):                                                 分配所需的内存空间，并返回一个指向它的指针。
10. void *realloc(void *ptr, size_t size):                                     尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。
11. void abort(void):                                                          使一个异常程序终止。
12. int atexit(void (*func)(void)):                                            当程序正常终止时，调用指定的函数 func。
13. void exit(int status):                                                     使程序正常终止。
14. char *getenv(const char *name):                                            搜索 name 所指向的环境字符串，并返回相关的值给字符串。
15. int system(const char *string):                                            由 string 指定的命令传给要被命令处理器执行的主机环境。
16. void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *)):           执行二分查找。
17. void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)):                                      数组排序。
18. int abs(int x):                                                            返回 x 的绝对值。
19. div_t div(int numer, int denom):                                           分子除以分母。
20. long int labs(long int x):                                                 返回 x 的绝对值。
21. ldiv_t ldiv(long int numer, long int denom):                               分子除以分母。
22. int rand(void):                                                            返回一个范围在 0 到 RAND_MAX 之间的伪随机数。
23. void srand(unsigned int seed):                                             该函数播种由函数 rand 使用的随机数发生器。
24. int mblen(const char *str, size_t n):                                      返回参数 str 所指向的多字节字符的长度。
25. size_t mbstowcs(schar_t *pwcs, const char *str, size_t n):                 把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组。
26. int mbtowc(whcar_t *pwc, const char *str, size_t n):                       检查参数 str 所指向的多字节字符。
27. size_t wcstombs(char *str, const wchar_t *pwcs, size_t n):                 把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中。
28. int wctomb(char *str, wchar_t wchar):                                      检查对应于参数 wchar 所给出的多字节字符的编码。

=======================================================================
<string.h>

The header defines one variable type, one macro, and various functions for manipulating arrays of characters.

Library Variables
1. size_t:   This is the unsigned integral type and is the result of the sizeof keyword.

Library Macros
1. NULL:   This macro is the value of a null pointer constant.


Library Functions
1. void *memchr(const void *str, int c, size_t n):                Searches for the first occurrence of the character c (an unsigned char) in the first n bytes of the string pointed to, by the argument str.
2. int memcmp(const void *str1, const void *str2, size_t n):      Compares the first n bytes of str1 and str2.
3. void *memcpy(void *dest, const void *src, size_t n):           Copies n characters from src to dest.
4. void *memmove(void *dest, const void *src, size_t n):          Another function to copy n characters from str2 to str1.
5. void *memset(void *str, int c, size_t n):                      Copies the character c (an unsigned char) to the first n characters of the string pointed to, by the argument str.
6. char *strcat(char *dest, const char *src):                     Appends the string pointed to, by src to the end of the string pointed to by dest.
7. char *strncat(char *dest, const char *src, size_t n):          Appends the string pointed to, by src to the end of the string pointed to, by destup to n characters long.
8. char *strchr(const char *str, int c):                          Searches for the first occurrence of the character c (an unsigned char) in the string pointed to, by the argument str.
9. int strcmp(const char *str1, const char *str2):                Compares the string pointed to, by str1 to the string pointed to by str2. 
10. int strncmp(const char *str1, const char *str2, size_t n):    Compares at most the first n bytes of str1 and str2.
11. int strcoll(const char *str1, const char *str2):              Compares string str1 to str2. The result is dependent on the LC_COLLATE setting of the location.
12. char *strcpy(char *dest, const char *src):                    Copies the string pointed to, by src to dest.
13 char *strncpy(char *dest, const char *src, size_t n):          Copies up to n characters from the string pointed to, by src to dest.
14. size_t strcspn(const char *str1, const char *str2):           Calculates the length of the initial segment of str1 which consists entirely of characters not in str2.
15. char *strerror(int errnum):                                   Searches an internal array for the error number errnum and returns a pointer to an error message string.
16. size_t strlen(const char *str):                               Computes the length of the string str up to but not including the terminating null character.
17. char *strpbrk(const char *str1, const char *str2):            Finds the first character in the string str1 that matches any character specified in str2.
18. char *strrchr(const char *str, int c):                        Searches for the last occurrence of the character c (an unsigned char) in the string pointed to by the argument str.
19. size_t strspn(const char *str1, const char *str2):            Calculates the length of the initial segment of str1 which consists entirely of characters in str2.
20. char *strstr(const char *haystack, const char *needle):       Finds the first occurrence of the entire string needle (not including the terminating null character) which appears in the string haystack.
21. char *strtok(char *str, const char *delim):                   Breaks string str into a series of tokens separated by delim.
22. size_t strxfrm(char *dest, const char *src, size_t n):        Transforms the first n characters of the string src into corrent locale and places them in the string dest



string.h定义了一个变量类型、一个宏和各种操作字符数组的函数。

1. size_t:  这是无符号整数类型，它是 sizeof 关键字的结果。
1. NULL:    这个宏是一个空指针常量的值。


1.  void *memchr(const void *str, int c, size_t n):               在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。
2.  int memcmp(const void *str1, const void *str2, size_t n):     把 str1 和 str2 的前 n 个字节进行比较。
3.  void *memcpy(void *dest, const void *src, size_t n):          从 src 复制 n 个字符到 dest。
4.  void *memmove(void *dest, const void *src, size_t n):         另一个用于从 str2 复制 n 个字符到 str1 的函数。
5.  void *memset(void *str, int c, size_t n):                     复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。
6.  char *strcat(char *dest, const char *src):                    把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。
7.  char *strncat(char *dest, const char *src, size_t n):         把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。
8.  char *strchr(const char *str, int c):                         在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。
9.  int strcmp(const char *str1, const char *str2):               把 str1 所指向的字符串和 str2 所指向的字符串进行比较。
10. int strncmp(const char *str1, const char *str2, size_t n):    把 str1 和 str2 进行比较，最多比较前 n 个字节。
11. int strcoll(const char *str1, const char *str2):              把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。
12. char *strcpy(char *dest, const char *src):                    把 src 所指向的字符串复制到 dest。
13. char *strncpy(char *dest, const char *src, size_t n):         把 src 所指向的字符串复制到 dest，最多复制 n 个字符。
14. size_t strcspn(const char *str1, const char *str2):           检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。
15. char *strerror(int errnum):                                   从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。
16. size_t strlen(const char *str):                               计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。
17. char *strpbrk(const char *str1, const char *str2):            检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。
18. char *strrchr(const char *str, int c):                        在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。
19. size_t strspn(const char *str1, const char *str2):            检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。
20. char *strstr(const char *haystack, const char *needle):       在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。
21. char *strtok(char *str, const char *delim):                   分解字符串 str 为一组字符串，delim 为分隔符。
22. size_t strxfrm(char *dest, const char *src, size_t n):        根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。








=======================================================================
<time.h>

The header defines four variable types, two macro and various functions for manipulating date and time.

Library Variables
1. size_t:      This is the unsigned integral type and is the result of the sizeof keyword.
2. clock_t:     This is a type suitable for storing the processor time.
3. time_t is:   This is a type suitable for storing the calendar time.
4. struct tm:   This is a structure used to hold the time and date.


struct tm {
int tm_sec;   /* seconds, range 0 to 59 */
int tm_min;   /* minutes, range 0 to 59 */
int tm_hour;  /* hours, range 0 to 23 */
int tm_mday;  /* day of the month, range 1 to 31 */
int tm_mon;   /* month, range 0 to 11 */
int tm_year;  /* The number of years since 1900 */
int tm_wday;  /* day of the week, range 0 to 6 */
int tm_yday;  /* day in the year, range 0 to 365 */
int tm_isdst; /* daylight saving time */
};


Library Macros
1. NULL:             This macro is the value of a null pointer constant.
2. CLOCKS_PER_SEC:   This macro represents the number of processor clocks per second.



Library Functions
1. char *asctime(const struct tm *timeptr):     Returns a pointer to a string which represents the day and time of the structure timeptr.
2. clock_t clock(void):                         Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
3. char *ctime(const time_t *timer):            Returns a string representing the localtime based on the argument timer.
4. double difftime(time_t time1, time_t time2): Returns the difference of seconds between time1 and time2 (time1-time2).
5. struct tm *gmtime(const time_t *timer):      The value of timer is broken up into the structure tm and expressed in Coordinated Universal Time (UTC), also known as Greenwich Mean Time (GMT).
6. struct tm *localtime(const time_t *timer):   The value of timer is broken up into the structure tm and expressed in the local time zone.
7. time_t mktime(struct tm *timeptr):           Converts the structure pointed to by timeptr into a time_t value according to the local time zone.
8. size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr):    Formats the time represented in the structure timeptr according to the formatting rules defined in format and stored into str.
9. time_t time(time_t *timer):                  Calculates the current calender time and encodes it into time_t format.


time.h定义了四个变量类型、两个宏和各种操作日期和时间的函数。

1. size_t:     是无符号整数类型，它是 sizeof 关键字的结果。
2. clock_t:    这是一个适合存储处理器时间的类型。
3. time_t is:  这是一个适合存储日历时间类型。
4. struct tm:  这是一个用来保存时间和日期的结构。

struct tm {
   int tm_sec;         /* 秒，范围从 0 到 59        */
   int tm_min;         /* 分，范围从 0 到 59        */
   int tm_hour;        /* 小时，范围从 0 到 23        */
   int tm_mday;        /* 一月中的第几天，范围从 1 到 31    */
   int tm_mon;         /* 月，范围从 0 到 11        */
   int tm_year;        /* 自 1900 年起的年数        */
   int tm_wday;        /* 一周中的第几天，范围从 0 到 6    */
   int tm_yday;        /* 一年中的第几天，范围从 0 到 365    */
   int tm_isdst;       /* 夏令时                */
};

1. NULL:            这个宏是一个空指针常量的值。
2. CLOCKS_PER_SEC:  这个宏表示每秒的处理器时钟个数。

1. char *asctime(const struct tm *timeptr):       返回一个指向字符串的指针，它代表了结构 timeptr 的日期和时间。
2. clock_t clock(void):                           返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。
3. char *ctime(const time_t *timer):              返回一个表示当地时间的字符串，当地时间是基于参数 timer。
4. double difftime(time_t time1, time_t time2):   返回 time1 和 time2 之间相差的秒数 (time1-time2)。
5. struct tm *gmtime(const time_t *timer):        timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。
6. struct tm *localtime(const time_t *timer):     timer 的值被分解为 tm 结构，并用本地时区表示。
7. time_t mktime(struct tm *timeptr):             把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。
8. size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr):         根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。
9. time_t time(time_t *timer):                    计算当前日历时间，并把它编码成 time_t 格式。








#==========================================================================
// https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html

1 基本解释：
extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其声明(extern只在变量或函数的声明中起作用)。此外extern也可用来进行链接指定。

即：extern有两个作用，(1):当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译该函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$，也可能是别的，因为不同的编译器采用的方法不一样，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
(2): 当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int;
它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块和其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用A模块(编译单元)中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，B模块虽然找不到该函数或变量，但它不会报错，它会在连接时从A模块生成的目标代码中找到此函数。

2 问题：extern 变量
　　在一个源文件里定义了一个数组：char a[6];
　　在另外一个文件里用下列语句进行了声明：extern char *a；
　　请问，这样可以吗？
　　答案与分析：
　　1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。
　　2)、例子分析如下，如果a[] = "abcd",则外部变量a=0x61626364 (abcd的ASCII码值)，*a显然没有意义
　　显然a指向的空间（0x61626364）没有意义，易出现非法内存访问。
　　3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。
　　4)、extern用在变量声明中常常有这样一个作用，你在*.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在*.h中并用extern来声明。

3 问题：当方面修改extern 函数原型
　　当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？
　　答案与分析：
　　目前业界针对这种情况的处理没有一个很完美的方案，通常的做法是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。
　　宝剑有双锋，对extern的应用，不同的场合应该选择不同的做法。

4 问题：extern “C”
　　在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？

　　答案与分析：
　　C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
　　下面是一个标准的写法：
//在.h文件的头上
#ifdef __cplusplus
 #if __cplusplus
  extern "C"{
 #endif
#endif /* __cplusplus */
　…
　…
//.h文件结束的地方
#ifdef __cplusplus
　#if __cplusplus
}
  #endif
#endif /* __cplusplus */ 

5 问题：extern 函数声明
　　常常见extern放在函数的前面成为函数声明的一部分，那么，C语言的关键字extern在函数的声明中起什么作用？
　　答案与分析：
　　如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即下述两个函数声明没有明显的区别：
extern int f(); 和int f();
　　当然，这样的用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。关于这样做的原因和利弊可见下面的这个例子：“用extern修饰的全局变量”

    (1) 在test1.h中有下列声明:
    #ifndef TEST1H
    #define TEST1H
    extern char g_str[]; // 声明全局变量g_str
    void fun1();
    #endif
    (2) 在test1.cpp中
    #include "test1.h"
        char g_str[] = "123456"; // 定义全局变量g_str
        void fun1() { cout << g_str << endl; }
    (3) 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了
    #include "test1.h"

     void fun2()    { cout << g_str << endl;    }
    以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraEdit打开test1.obj,你可以在里面找到"123456"这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份,test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!
    (4) 有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为
    extern char g_str[] = "123456"; // 这个时候相当于没有extern
    然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报连接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而test2.cpp也包含了test1.h所以再一次定义了g_str,这个时候连接器在连接test1和test2时发现两个g_str。如果你非要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include "test1.h"去掉 换成:
    extern char g_str[];
    void fun2()   {  cout << g_str << endl;   }
   这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是我想说这样做非常糟糕，因为你由于无法在test2.cpp中使用#include "test1.h",那么test1.h中声明的其他函数你也无法使用了，除非也用都用extern修饰，这样的话你光声明的函数就要一大串，而且头文件的作用就是要给外部提供接口使用的，所以 请记住， 只在头文件中做声明，真理总是这么简单。

6. extern 和 static

 (1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.
 (2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.

    static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:
    (1) test1.h:
    #ifndef TEST1H
    #define TEST1H
    static char g_str[] = "123456";
    void fun1();
    #endif

    (2) test1.cpp:
    #include "test1.h"
    void fun1()  {   cout << g_str << endl;  }
    (3) test2.cpp
    #include "test1.h"
    void fun2()  {   cout << g_str << endl;  }
    以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串"123456",同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1,test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的"123456", 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了，如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:
    (1) test1.cpp:
    #include "test1.h"
    void fun1()
    {
        g_str[0] = ''a'';
        cout << g_str << endl;
    }

    (2) test2.cpp
    #include "test1.h"
    void fun2()  {  cout << g_str << endl;  }
    (3) void main()     {
        fun1(); // a23456
        fun2(); // 123456
    }
    这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。正是因为static有以上的特性，所以一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染，同样记住这个原则吧！

7. extern 和const

   C++中const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，但是const可以与extern连用来声明该常量可以作用于其他编译模块中, 如extern const char g_str[];
    然后在原文件中别忘了定义:     const char g_str[] = "123456"; 

    所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了！所以对const我没有什么可以过多的描述，我只是想提醒你，const char* g_str = "123456" 与 const char g_str[] ="123465"是不同的， 前面那个const 修饰的是char *而不是g_str,它的g_str并不是常量，它被看做是一个定义了的全局变量（可以被其他编译单元使用）， 所以如果你像让char*g_str遵守const的全局常量的规则，最好这么定义const char* const g_str="123456".

---------------------------------------------------------------------
假如a.h中有 int a=10; t1.cpp和t2.cpp同时include "a.h"则编译不成功，因为a重复定义；
如果 a.h中是 static int a=10;则可以，因为t1和t2中的a只是名字相同，地址空间不同；
如果a.h中是 extern int a; 并且在a.cpp中 int a=10; 则t1和t2中的a指向同一个地址空间。

在头文件中定义全局变量，如果该头文件不被任何.c或者.cpp中包含的话，该变量的定义是没有意义的，即使加了extern 关键字。因为在变量定义中，extern关键字是不起作用的，extern只用作声明。
编译器在编译时，是不管头文件的，只有在预处理时会include头文件中的内容，也就是把头文件中的内容全盘粘贴过来。因此，如果你只是在头文件中定义变量，而不include头文件，这时，编译器无论是在预处理阶段，还是在链接阶段，直接无视头文件的存在(链接器只会在.c/.cpp生成的目标文件(.o)中查找变量名）。这样一来，头文件中定义的变量也就形同虚设，完全没有意义可言。

---------------------------------------------------------------------


// https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777416.html

为什么使用const？采用符号常量写出的代码更容易维护；指针常常是边读边移动，而不是边写边移动；许多函数参数是只读不写的。const最常见用途是作为数组的界和switch分情况标号(也可以用枚举符代替)，分类如下：

  常变量：  const 类型说明符 变量名

  常引用：  const 类型说明符 &引用名

  常对象：  类名 const 对象名

  常成员函数：  类名::fun(形参) const

  常数组：  类型说明符 const 数组名[大小]    

  常指针：  const 类型说明符* 指针名 ，类型说明符* const 指针名

首先提示的是：在常变量（const 类型说明符 变量名）、常引用（const 类型说明符 &引用名）、常对象（类名 const 对象名）、 常数组（类型说明符 const 数组名[大小]）， const” 与 “类型说明符”或“类名”（其实类名是一种自定义的类型说明符） 的位置可以互换。如：

     const int a=5; 与 int const a=5; 等同

     类名 const 对象名 与 const 类名 对象名 等同

用法1：常量
    取代了C中的宏定义，声明时必须进行初始化(!c++类中则不然）。const限制了常量的使用方式，并没有描述常量应该如何分配。如果编译器知道了某const的所有使用，它甚至可以不为该const分配空间。最简单的常见情况就是常量的值在编译时已知，而且不需要分配存储。―《C++ Program Language》
    用const声明的变量虽然增加了分配空间，但是可以保证类型安全。
    C标准中，const定义的常量是全局的，C++中视声明位置而定。

用法2：指针和常量
    使用指针时涉及到两个对象：该指针本身和被它所指的对象。将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符*const。
    所以出现在 * 之前的const是作为基础类型的一部分：
char *const cp; //到char的const指针
char const *pc1; //到const char的指针
const char *pc2; //到const char的指针（后两个声明是等同的）
    从右向左读的记忆方式：
cp is a const pointer to char. 故pc不能指向别的字符串，但可以修改其指向的字符串的内容
pc2 is a pointer to const char. 故*pc2的内容不可以改变，但pc2可以指向别的字符串

且注意：允许把非 const 对象的地址赋给指向 const 对象的指针,不允许把一个 const 对象的地址赋给一个普通的、非 const 对象的指针。

用法3：const修饰函数传入参数
    将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。
    通常修饰指针参数和引用参数：
void Fun( const A *in); //修饰指针型传入参数
void Fun(const A &in); //修饰引用型传入参数

用法4：修饰函数返回值
    可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。

用法5：const修饰成员函数(c++特性)
const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；
const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；
const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。

具体展开来讲：
(一). 常量与指针

 常量与指针放在一起很容易让人迷糊。对于常量指针和指针常量也不是所有的学习C/C++的人都能说清除。例如：

    const int *m1 = new int(10);

    int* const m2 = new int(20);

在上面的两个表达式中，最容易让人迷惑的是const到底是修饰指针还是指针指向的内存区域？其实，只要知道：const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用。根据这个规则来判断，m1应该是常量指针（即，不能通过m1来修改它所指向的内容。）；而m2应该是指针常量（即，不能让m2指向其他的内存模块）。由此可见：

   1. 对于常量指针，不能通过该指针来改变所指的内容。即，下面的操作是错误的：

      int i = 10;

      const int *pi = &i;

      *pi = 100;

      因为你在试图通过pi改变它所指向的内容。但是，并不是说该内存块中的内容不能被修改。我们仍然可以通过其他方式去修改其中的值。例如：

      // 1: 通过i直接修改。

      i = 100;

      // 2:　使用另外一个指针来修改。

      int *p = (int*)pi;

      *p = 100;

      实际上，在将程序载入内存的时候，会有专门的一块内存区域来存放常量。但是，上面的i本身不是常量，是存放在栈或者堆中的。我们仍然可以修改它的值。而pi不能修改指向的值应该说是编译器的一个限制。
   2. 根据上面const的规则，const int *m1 = new int(10);我们也可写作：

      int const　*m1 = new int(10);

      这是，理由就不须作过多说明了。
   3. 在函数参数中指针常量时表示不允许将该指针指向其他内容。

      void func_02(int* const p)

      {

      int *pi = new int(100);

      //错误！P是指针常量。不能对它赋值。

      p = pi;

      }

      int main()

      {

      int* p = new int(10);

      func_02(p);

      delete p;

      return 0;

      }

   4. 在函数参数中使用常量指针时表示在函数中不能改变指针所指向的内容。

    void func(const int *pi)

    {

    //错误！不能通过pi去改变pi所指向的内容！

    *pi = 100;

    }

    int main()

    {

    int* p = new int(10);

    func(p);　

    delete p;

    return 0;

    }

　　我们可以使用这样的方法来防止函数调用者改变参数的值。但是，这样的限制是有限的，作为参数调用者，我们也不要试图去改变参数中的值。因此，下面的操作是在语法上是正确的，但是可能破还参数的值：

    #include <iostream>

    #include <string>

    void func(const int *pi)

    {

    //这里相当于重新构建了一个指针，指向相同的内存区域。当然就可以通过该指针修改内存中的值了。

    int* pp = (int*)pi;

    *pp = 100;

    }

    int main()

    {

    using namespace std;

    int* p = new int(10);

    cout << "*p = " << *p << endl;

    func(p);

    cout << "*p = " << *p << endl;

    delete p;

    return 0;

    }

(二)：常量与引用

    常量与引用的关系稍微简单一点。因为引用就是另一个变量的别名，它本身就是一个常量。也就是说不能再让一个引用成为另外一个变量的别名, 那么他们只剩下代表的内存区域是否可变。即：

    int i = 10;

    // 正确：表示不能通过该引用去修改对应的内存的内容。

    const int& ri = i;

    // 错误！不能这样写。

    int& const rci = i;

    由此可见，如果我们不希望函数的调用者改变参数的值。最可靠的方法应该是使用引用。下面的操作会存在编译错误：

    void func(const int& i)

    {

    // 错误！不能通过i去改变它所代表的内存区域。

    i = 100;

    }

    int main()

    {

    int i = 10;

    func(i);

    return 0;

    }

    这里已经明白了常量与指针以及常量与引用的关系。但是，有必要深入的说明以下。在系统加载程序的时候，系统会将内存分为4个区域：堆区 栈区全局区（静态）和代码区。从这里可以看出，对于常量来说，系统没有划定专门的区域来保护其中的数据不能被更改。也就是说，使用常量的方式对数据进行保护是通过编译器作语法限制来实现的。我们仍然可以绕过编译器的限制去修改被定义为“常量”的内存区域。看下面的代码：

    const int i = 10;

    // 这里i已经被定义为常量，但是我们仍然可以通过另外的方式去修改它的值。

    // 这说明把i定义为常量，实际上是防止通过i去修改所代表的内存。

    int *pi = (int*) &i;

(三)：常量函数

    常量函数是C++对常量的一个扩展，它很好的确保了C++中类的封装性。在C++中，为了防止类的数据成员被非法访问，将类的成员函数分成了两类，一类是常量成员函数（也被称为观察着）；另一类是非常量成员函数（也被成为变异者）。在一个函数的签名后面加上关键字const后该函数就成了常量函数。对于常量函数，最关键的不同是编译器不允许其修改类的数据成员。例如：

    class Test

    {

    public:

    void func() const;

    private:

    int intValue;

    };

    void Test::func() const

    {

    intValue = 100;

    }

    上面的代码中，常量函数func函数内试图去改变数据成员intValue的值，因此将在编译的时候引发异常。

    当然，对于非常量的成员函数，我们可以根据需要读取或修改数据成员的值。但是，这要依赖调用函数的对象是否是常量。通常，如果我们把一个类定义为常量，我们的本意是希望他的状态（数据成员）不会被改变。那么，如果一个常量的对象调用它的非常量函数会产生什么后果呢？看下面的代码：

    class Fred{

    public:

    void inspect() const;

    void mutate();

    };

    void UserCode(Fred& changeable, const Fred& unChangeable)

    {

    changeable.inspect(); // 正确，非常量对象可以调用常量函数。

    changeable.mutate(); // 正确，非常量对象也允许修改调用非常量成员函数修改数据成员。

    unChangeable.inspect(); // 正确，常量对象只能调用常理函数。因为不希望修改对象状态。

    unChangeable.mutate(); // 错误！常量对象的状态不能被修改，而非常量函数存在修改对象状态的可能

    }

    从上面的代码可以看出，由于常量对象的状态不允许被修改，因此，通过常量对象调用非常量函数时将会产生语法错误。实际上，我们知道每个成员函数都有一个隐含的指向对象本身的this指针。而常量函数则包含一个this的常量指针。如下：

    void inspect(const Fred* this) const;

    void mutate(Fred* this);

     也就是说对于常量函数，我们不能通过this指针去修改对象对应的内存块。但是，在上面我们已经知道，这仅仅是编译器的限制，我们仍然可以绕过编译器的限制，去改变对象的状态。看下面的代码：

    class Fred{

    public:

    void inspect() const;
    private:

    int intValue;

    };

    void Fred::inspect() const

    {

    cout << "At the beginning. intValue = "<< intValue << endl;

    // 这里，我们根据this指针重新定义了一个指向同一块内存地址的指针。

    // 通过这个新定义的指针，我们仍然可以修改对象的状态。

    Fred* pFred = (Fred*)this;

    pFred->intValue = 50;

    cout << "Fred::inspect() called. intValue = "<< intValue << endl;

    }

    int main()

    {

    Fred fred;

    fred.inspect();

    return 0;

    }

    上面的代码说明，只要我们愿意，我们还是可以通过常量函数修改对象的状态。同理，对于常量对象，我们也可以构造另外一个指向同一块内存的指针去修改它的状态。这里就不作过多描述了。

    另外，也有这样的情况，虽然我们可以绕过编译器的错误去修改类的数据成员。但是C++也允许我们在数据成员的定义前面加上mutable，以允许该成员可以在常量函数中被修改。例如：

    class Fred{

    public:

    void inspect() const;

    private:

    mutable int intValue;

    };

    void Fred::inspect() const

    {

    intValue = 100;

    }

    但是，并不是所有的编译器都支持mutable关键字。这个时候我们上面的歪门邪道就有用了。

    关于常量函数，还有一个问题是重载。

    #include <iostream>

    #include <string>

    using namespace std;

    class Fred{

    public:

    void func() const;

    void func();

    };

    void Fred::func() const

    {

    cout << "const function is called."<< endl;

    }

    void Fred::func()

    {

    cout << "non-const function is called."<< endl;

    }

    void UserCode(Fred& fred, const Fred& cFred)

    {

    cout << "fred is non-const object, and the result of fred.func() is:" << endl;

    fred.func();

    cout << "cFred is const object, and the result of cFred.func() is:" << endl;

    cFred.func();

    }

    int main()

    {

    Fred fred;

    UserCode(fred, fred);

    return 0;

    }

    输出结果为：

    fred is non-const object, and the result of fred.func() is:

    non-const function is called.

    cFred is const object, and the result of cFred.func() is:

    const function is called.

    从上面的输出结果，我们可以看出。当存在同名同参数和返回值的常量函数和非常量函数时，具体调用哪个函数是根据调用对象是常量对像还是非常量对象来决定的。常量对象调用常量成员；非常量对象调用非常量的成员。

    总之，我们需要明白常量函数是为了最大程度的保证对象的安全。通过使用常量函数，我们可以只允许必要的操作去改变对象的状态，从而防止误操作对对象状态的破坏。但是，就像上面看见的一样，这样的保护其实是有限的。关键还是在于我们开发人员要严格的遵守使用规则。另外需要注意的是常量对象不允许调用非常量的函数。这样的规定虽然很武断，但如果我们都根据原则去编写或使用类的话这样的规定也就完全可以理解了。
(四)：常量返回值

     很多时候，我们的函数中会返回一个地址或者引用。调用这得到这个返回的地址或者引用后就可以修改所指向或者代表的对象。这个时候如果我们不希望这个函数的调用这修改这个返回的内容，就应该返回一个常量。这应该很好理解，大家可以去试试。

+++++++++++++++++++++++++++++++++++++++

c++ 中const

+++++++++++++++++++++++++++++++++++++++

1. const常量，如const int max = 100; 
优点：const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误（边际效应）
2.  const 修饰类的数据成员。如：
class A
{

    const int size;

    …

}

const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。如

class A

{

 const int size = 100;    //错误

 int array[size];         //错误，未知的size

}
const数据成员的初始化只能在类的构造函数的初始化表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现。如

class A

{…

 enum {size1=100, size2 = 200 };

int array1[size1];

int array2[size2];

}

枚举常量不会占用对象的存储空间，他们在编译时被全部求值。但是枚举常量的隐含数据类型是整数，其最大值有限，且不能表示浮点数。

3. const修饰指针的情况，见下式：

int b = 500;
const int* a = &                  [1]
int const *a = &                  [2]
int* const a = &                  [3]
const int* const a = &       [4]

如果你能区分出上述四种情况，那么，恭喜你，你已经迈出了可喜的一步。不知道，也没关系，我们可以参考《Effectivec++》Item21上的做法，如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。

4. const的初始化

先看一下const变量初始化的情况
1) 非指针const常量初始化的情况：A b;
const A a = b;

2) 指针const常量初始化的情况：

A* d = new A();
const A* c = d;
或者：const A* c = new A();
3）引用const常量初始化的情况：
A f;
const A& e = f;      // 这样作e只能访问声明为const的函数，而不能访问一般的成员函数；

    [思考1]： 以下的这种赋值方法正确吗？
    const A* c=new A();
    A* e = c;
    [思考2]： 以下的这种赋值方法正确吗？
    A* const c = new A();
    A* b = c;

5. 另外const 的一些强大的功能在于它在函数声明中的应用。在一个函数声明中，const可以修饰函数的返回值，或某个参数；对于成员函数，还可以修饰是整个函数。有如下几种情况，以下会逐渐的说明用法：A&operator=(const A& a);
void fun0(const A* a );
void fun1( ) const; // fun1( ) 为类成员函数
const A fun2( );

1) 修饰参数的const，如 void fun0(const A* a ); void fun1(const A& a);
调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，如形参为const A*a，则不能对传递进来的指针的内容进行改变，保护了原指针所指向的内容；如形参为const A&a，则不能对传递进来的引用对象进行改变，保护了原对象的属性。
[注意]：参数const通常用于参数为指针或引用的情况，且只能修饰输入参数;若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。

[总结]对于非内部数据类型的输入参数，因该将“值传递”的方式改为“const引用传递”，目的是为了提高效率。例如，将void Func(A a)改为void Func(const A &a)

      对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x)不应该改为void Func(const int &x)

2)  修饰返回值的const，如const A fun2( ); const A* fun3( );
这样声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。const Rational operator*(const Rational& lhs, const Rational& rhs)
{
return Rational(lhs.numerator() * rhs.numerator(),
lhs.denominator() * rhs.denominator());
}

返回值用const修饰可以防止允许这样的操作发生:Rational a,b;
Radional c;
(a*b) = c;

一般用const修饰返回值为对象本身（非引用和指针）的情况多用于二目操作符重载函数并产生新对象的时候。
[总结]

1.  一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A实例）或某个对象的引用为const（const A& test = A实例），则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。

2.  如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。如：

const char * GetString(void);

如下语句将出现编译错误：

char *str=GetString();

正确的用法是：

const char *str=GetString();

3.     函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赙值函数中，目的是为了实现链式表达。如：

class A

{…

 A &operate = (const A &other);  //负值函数

}
A a,b,c;              //a,b,c为A的对象

…

a=b=c;            //正常

(a=b)=c;          //不正常，但是合法

若负值函数的返回值加const修饰，那么该返回值的内容不允许修改，上例中a=b=c依然正确。(a=b)=c就不正确了。
[思考3]： 这样定义赋值操作符重载函数可以吗？
const A& operator=(const A& a);

6.     类成员函数中const的使用
一般放在函数体后，形如：void fun() const;
任何不会修改数据成员的函数都因该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其他非const成员函数，编译器将报错，这大大提高了程序的健壮性。如：

class Stack

{

 public:

      void Push(int elem);

      int Pop(void);

      int GetCount(void) const;   //const 成员函数

 private:

      int m_num;

      int m_data[100];

};

int Stack::GetCount(void) const

{

  ++m_num;              //编译错误，企图修改数据成员m_num

  Pop();                    //编译错误，企图调用非const函数

  Return m_num;

}

7. 使用const的一些建议

1) 要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；
2) 要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题；
3) 在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；
4) const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；
5) 不要轻易的将函数的返回值类型定为const;
6) 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;

[思考题答案]
1) 这种方法不正确，因为声明指针的目的是为了对其指向的内容进行改变，而声明的指针e指向的是一个常量，所以不正确；
2) 这种方法正确，因为声明指针所指向的内容可变；
3) 这种做法不正确；
在const A::operator=(const A& a)中，参数列表中的const的用法正确，而当这样连续赋值的时侯，问题就出现了：
A a,b,c:
(a=b)=c;
因为a.operator=(b)的返回值是对a的const引用，不能再将c赋值给const常量。

++++++++++++++++++++++++++++++++++++++++

const 在c和c++中的区别  http://tech.e800.com.cn/articles/2009/722/1248229886744_1.html

++++++++++++++++++++++++++++++++++++++++

1. C++中的const正常情况下是看成编译期的常量,编译器并不为const分配空间,只是在编译的时候将期值保存在名字表中,并在适当的时候折合在代码中.所以,以下代码:
using namespace std;
int main()
{
const int a = 1;
const int b = 2;
int array[ a + b ] = {0};
for (int i = 0; i < sizeof array / sizeof *array; i++)
{
cout << array << endl;
}
}
在可以通过编译,并且正常运行.但稍加修改后,放在C编译器中,便会出现错误:
int main()
{
int i;
const int a = 1;
const int b = 2;
int array[ a + b ] = {0};
for (i = 0; i < sizeof array / sizeof *array; i++)
{
printf("%d",array);
}
}
错误消息:
c:\test1\te.c(8): error C2057: 应输入常数表达式
c:\test1\te.c(8): error C2466: 不能分配常数大小为 0 的数组
出现这种情况的原因是:在C中,const是一个不能被改变的普通变量,既然是变量,就要占用存储空间,所以编译器不知道编译时的值.而且,数组定义时的下标必须为常量.
2. 在C语言中: const int size; 这个语句是正确的，因为它被C编译器看作一个声明,指明在别的地方分配存储空间.但在C++中这样写是不正确的.C++中const默认是内部连接,如果想在C++中达到以上的效果,必须要用extern关键字.即C++中,const默认使用内部连接.而C中使用外部连接.
(1) 内连接:编译器只对正被编译的文件创建存储空间,别的文件可以使用相同的表示符或全局变量.C/C++中内连接使用static关键字指定.
(2) 外连接:所有被编译过的文件创建一片单独存储空间.一旦空间被创建,连接器必须解决对这片存储空间的引用.全局变量和函数使用外部连接.通过extern关键字声明,可以从其他文件访问相应的变量和函数.
/* C++代码  header.h */
const int test = 1;
/* C++代码  test1.cpp */
#include "header.h"
using namespace std;
int main() { cout << "in test1 :" << test << endl; }
/* C++代码 test2.cpp */
#include "header.h"
using namespace std;
void print() { cout << "in test2:" << test << endl;}
以上代码编译连接完全不会出问题,但如果把header.h改为:
extern const int test = 1;
在连接的时候,便会出现以下错误信息:
test2 error LNK2005: "int const test" (?test@@3HB) 已经在 test1.obj 中定义
    因为extern关键字告诉C++编译器test会在其他地方引用,所以,C++编译器就会为test创建存储空间,不再是简单的存储在名字表里面.所以,当两个文件同时包含header.h的时候,会发生名字上的冲突.
此种情况和C中const含义相似:
/* C代码 header.h */
const int test = 1;
/* C代码 test1.c */
#include "header.h"
int main() { printf("in test1:%d\n",test); }
/* C代码 test2.c */
#include "header.h"
void print() { printf("in test2:%d\n",test); }
错误消息:
test3 fatal error LNK1169: 找到一个或多个多重定义的符号
test3 error LNK2005: _test 已经在 test1.obj 中定义

也就是说：在c++ 中const 对象默认为文件的局部变量。与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。通过指定 const 变更为 extern，就可以在整个程序中访问 const 对象：
      // file_1.cc
      // defines and initializes a const that is accessible to other files
      extern const int bufSize = fcn();
      // file_2.cc
      extern const int bufSize; // uses bufSize from file_1
      // uses bufSize defined in file_1
      for (int index = 0; index != bufSize; ++index)
            // ...

3. C++中,是否为const分配空间要看具体情况.如果加上关键字extern或者取const变量地址,则编译器就要为const分配存储空间.
4. C++中定义常量的时候不再采用define,因为define只做简单的宏替换，并不提供类型检查.






































